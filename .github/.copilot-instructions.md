# Agent Behavior Guidelines

Constitutional principles for working on the Emulation File Manager project.

## Core Principles

### Always Explain Your Reasoning
- Explain which layer code belongs to and why
- Describe trade-offs between different approaches
- Reference the 4-layer architecture when making decisions
- Call out any deviations from established patterns

### Start with Design, Then Implementation
For non-trivial features:
1. Use the **architect agent** for design and layer placement
2. Use the **database agent** for schema and repositories
3. Use the **gui agent** for UI components

### Prefer Small, Focused Changes
- Make surgical changes to address specific issues
- Avoid large refactors unless explicitly requested
- Don't fix unrelated bugs or style issues
- One logical change per commit/PR

## The 4-Layer Architecture (Non-Negotiable)

**Layer Order:** Core → Database → Service → GUI

**Rules:**
- Upper layers can depend on lower layers, never reverse
- Core crates have NO dependencies on other project crates
- Business logic lives in service layer
- Database crate owns all data access

**Quick Decision Guide:**
- Domain type? → Core crate
- Data access? → Database crate  
- Business logic? → Service crate
- User interface? → GUI crate

## Critical Non-Negotiables

### SQLx Offline Mode
**ALWAYS** regenerate after query or schema changes:
```bash
cargo sqlx prepare --workspace -- --all-targets
```
CI will fail without up-to-date `.sqlx/` metadata.

### Layer Boundaries
**NEVER:**
- Add SQLx queries in GUI code
- Add business logic in database repositories
- Skip service layer (GUI → Database directly)
- Add project dependencies to core crates

### Error Handling
- All public APIs return `Result<T, Error>`
- Propagate errors, don't panic in production
- `unwrap()` only acceptable in tests

## When to Use Which Agent

| Need | Agent | Why |
|------|-------|-----|
| Where should X live? | architect | Understands layers & boundaries |
| Add table or query | database | Knows SQLx patterns & migrations |
| Create UI component | gui | Knows relm4 patterns & gotchas |
| Write tests or mocks | test | Knows testing patterns & mocks |
| Review design | architect | Evaluates trade-offs |

**Detailed implementation patterns are in the specialized agent profiles—not here.**

## Technical Requirements

### Async Runtime
Use async-std as the async runtime throughout the application.
- All async code uses async-std, not tokio
- Database: SQLx with "runtime-async-std" feature
- Tests: Use #[async_std::test] attribute

### Code Conventions
- Edition: Rust 2024
- No unwrap() in production code (tests OK)
- Prefer ? operator over unwrap/expect
- Pipeline steps in service layer is an exception to use expect when the value is tested in should_execute
- Use descriptive variable names

### Dependencies
When adding crates, prefer:
- async-std over tokio (consistency)
- Well-maintained crates with active development
- Minimal dependency trees

## Validation Checklist

After making changes:
- [ ] `cargo test` passes
- [ ] `cargo build` succeeds
- [ ] Regenerated `.sqlx/` if queries changed
- [ ] Ran `tbls doc` if schema changed
- [ ] No layer boundary violations

## When in Doubt

1. Check existing patterns in similar code
2. Ask clarifying questions
3. Prefer explicit over clever
4. Consult the appropriate specialized agent

---

**Keep this file lean.** Detailed technical patterns belong in specialized agent profiles (`.github/agents/`).
